# 로또

## 요구 사항

1. 로또 번호의 숫자 범위는 1~45
2. 로또 발행 시 중복되지 않는 숫자 6개
3. 당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개
4. 로또 한장은 천원, 구입 금액을 입력하면 구입 금액에 해당하는 만큼 로또 발행.
5. 당첨 번호와 보너스 번호를 입력 받는다.
   1. 쉼표 기준으로 구분 (6개)
   2. 보너스 번호 입력
6. 출력
   1. 로또 수량 및 번호 출력
      1. 로또 번호는 오름차순
   2. 당첨 내역 출력 및 수익률

## 추가된 요구 사항

1. 도메인 로직에 단위 테스트를 구현

   1. 핵심 로직을 구현하는 코드와 UI 담당하는 로직을 구분한다.

1. Lotto 클래스
   1. Lotto에 필드 추가 안 됨

## 구현할 기능 목록

0. 사용자가 잘못된 값을 입력한 경우 `throw` 예외 처리 후 재입력 받는다!

1. (입력) 로또 구입 금액 입력

   - 1000원 단위로 로또 갯수 구하기

     > [예외]
     >
     > - 1000원 단위로 떨어지지 않을 경우
     > - 문자가 삽입된 경우 (**예외처리 중요**)
     >   (ex. 1000j, 1o00, -1000: 음수를 나타내는 것도 문자 처리)

2. (출력) 로또 구매
   2.1 (출력) 로또 구매 갯수 출력
   2.2 (출력) 구매 갯수만큼 로또 번호 출력

   > [조건]
   > 오름차순으로 ~~배열~~ -> **배열처럼 보이는 문자열**
   > 생성된 로또 번호들은 중복 없는 랜덤 숫자를 뽑는 유틸 사용.

3. (입력) 사용자(=로또) 번호 입력받기
   3.1 당첨 번호(`winningNumbers`) 6개 번호를 입력 받기

   > [조건]
   > , 쉼표로 구분

   > [예외]
   >
   > 1. 6개 이하
   > 2. 빈 문자열일 때 체크 (`', 3'`, `',3 ,'`)
   > 3. 중복인 경우
   > 4. 1 ~ 45 사이
   > 5. `',,'` 연속되는 경우 (0으로 처리)
   > 6. 숫자 받아서 ,로 나누고 빈문자열은 `trim()` 처리??

   3.2 보너스 번호(`bonusNumber`) 입력 받기

   > [조건]
   > 숫자는 하나, 범위는 1-45, 당첨 번호와 겹치면 안 됨

4. (출력) 당첨 내역 출력

   > [조건]
   > 5개 당첨 -> 5개 보너스 당첨
   > ~~객체~~ 대신 `Map` 사용하여 순서 대로 출력 보장

5. (출력) 총 수익률 계산

   > [조건]
   > 수익률은 소수점 둘째 자리 반올림한다.
   > 1000단위가 넘어가면 ,로 구분지어 포매팅해준다.
   > (ex. 62.5% 20,000.0%)

## 3주 차 목표

1. 함수 분리, 함수별 테스트
2. 클래스 분리 연습
3. 도메인 로직에 대한 단위 테스트를 작성하는 연습
4. 작은 기능부터 테스트를 작성하는 연습부터!!

---

### 에러 및 리팩토링 하면서 알게된 개념, 조우한 에러 해결법 등..

#### 1. `LottoNumberCreation.js`

     유틸성 클래스로 인스턴스를 만들 필요 없음. -> `static` 메서드 사용.

#### 2. 의존성 주입?

    객체가 필요로 하는 다른 객체를 외부에서 주입 받는 패턴

의존성 주입이 없는 경우, 클래스 내부에서 사용되는 값을 인스턴스 변수(프라이빗 필드)로 선언하는 것이 일반적이다.  
그러나 모두 로컬 변수로 설정을 하면, 메서드들 사이에서 값을 전달하기 위해 이 값들을 메서드의 인자로 전달해야 한다. -> 코드 가독성 저하.

이런 경우 2가지 방법이 있다.

1. 인스턴스 변수 사용 : App 클래스의 메서드들이 공유하는 값을 인스턴스 변수로 선언하고, 이를 통해 값을 전달한다.  
   메서드의 인자 수를 줄일 수 있다. 그러나 클래스의 상태를 관리해야 한다.

2. 메서드 인자 사용 : 공유하는 값을 메서드의 인자로 전달한다. 클래스의 상태관리는 필요 없지만, 인자 수가 많아져 가독성이 떨어진다.

#### 3. `call(this)`와 `bind(this)`

_`apply(this)`는 `call`과 비교하여 전달받은 매개변수 형태가 다름._

- 공통점 : this를 현재 컨텍스트로 설정하여 함수를 호출
- 차이점 : 당장 실행하느냐, 나중에 호출하느냐

  3.1. `call(this)` 를 함수를 즉시 호출
  : 즉시 호출을 하면서 무한 루프가 계속해서 돌았다. 내가 원하는 루프가 아니었음.

  3.2. `bind(this)`는 그저 `this`를 현재 컨텍스트로 고정만 하는 새로운 함수가 된다.
  : 고정을 해주기 때문에 나중에 함수를 호출할 수 있게 되므로 정상값을 받을 때 까지 원하는 루프가 돌게 됨.

  > 이전에 퍼블리싱 일을 할 때에, 이벤트 핸들러의 콜백 함수에 `.bind(this)`를 해줬었다.
  > 이를 통해 `컨텍스트 고정`과 `콜백 함수를 원하는 때에 나중에 호출` 할 수 있다고 개념만 아는 상태로 습관적으로 사용해왔다.
  > 명확한 상황이 없어서 이 둘의 차이를 제대로 인지하지 못하고 있었는데, 이번에 재입력 기능을 통해 명확히 알게 됨.

#### 4. 프로그래밍에서 발생할 수 있는 문제 상황에 대응하는 방법.

`try-catch`를 통한 예외 처리

처음에는 이전과 같이 `throw error`하고 끝나는 줄 알았다.. 요구 사항을 정확하게 파악하자.

##### `오류 처리(Error Handling)`와 `예외 처리(Exception Handling)`

5.1. 오류 처리(Error Handling)
: 오류 처리는 코드 실행 중에 발생할 수 있는 예상 가능한 문제 상황에 대응하는 방법을 의미합니다. 예를 들어, 사용자가 잘못된 입력을 제공하는 경우나 파일이 없는 경우 등입니다. 이러한 상황을 처리하기 위해 프로그램은 오류 상황을 검출하고 적절히 대응해야 합니다.

5.2. 예외 처리(Exception Handling)
: 예외 처리는 코드 실행 중에 발생할 수 있는 예상하지 못한 문제 상황, 즉 예외 상황에 대응하는 방법을 의미합니다. 예외는 일반적으로 프로그램의 정상적인 흐름을 방해하는 상황을 나타냅니다. 이러한 상황에서 프로그램은 예외를 `"던지고(throw)"`, 이를 `"잡아서(catch)"` 적절한 조치를 취해야 합니다.

#### 5. 순서를 보장하려면, 객체보다는 Map을 사용해보자. (Order Guarantee)
